#' corx
#'
#' Creates an object of class 'corx'. This function calculates correlation matrices. It stores effect sizes, p-values, the number of pairwise observations, and a formatted correlation matrix in a list. The argument 'z' allows for control variables to be assigned. If z does not equal NULL, partial correlations are performed. Methods are exported for the generic functions 'print', 'plot', 'summary', 'data.frame' and, 'coef'.
#' @param data A data.frame or matrix
#' @param x a vector of rownames. Defaults to all
#' @param y a vector of colnames. If not supplied, y is set to x.
#' @param z a vector of colnames. Control variables to be used in partial correlations - defaults to NULL
#' @param method a string. One of "pearson", "spearman", or "kendall"
#' @param round a scalar. Number of digits in printing
#' @param stars a numeric vector. This argument defines cut-offs for p-value stars.
#' @param remove_lead a logical. if TRUE (the default), leading zeros are removed in summaries
#' @param triangle one of "lower", "upper" or NULL (the default)
#' @param caption table caption. Passed to plots
#' @param note table note
#' @param describe a list of functions. If functions are supplied to describe, new columns will be bound to the 'APA matrix' for each function in the list. Describe also accepts a variety of shortcuts. If describe is set to TRUE, mean and standard deviation are returned for all row variables. Describe can accept a character vector to call the following descriptive functions: c('mean','sd','var','median','iqr','skewness','kurtosis'). These shortcuts are powered by 'tidyselect'. Skewness and kurtosis are calculated using the 'moments' package. All functions retrieved with shortcuts remove missing values.
#' @param grey_nonsig a logical. Should non-significant values be grey in output? This argument does nothing if describe is not set to FALSE
#' @param call_only For debugging, if TRUE only the call is returned
#' @details 'corx' constructs intercorrelation matrices using 'psych::corr.test'. P-values attained are not adjusted for multiple comparisons. The argument z can be used to specify control variables. If control variables are specified, partial correlations are calculated using 'ppcor::ppcor.test'. Asymmetrical correlation matrices can be constructed using the arguments 'x' and 'y'. The arguments 'x', 'y', and 'z' are powered by 'tidyselect::vars_select'.
#' @examples
#' cor_mat <- corx(mtcars, x = c(mpg,cyl,disp), y = c(wt,drat,disp,qsec),
#'            z = wt, round = 2, stars = c(0.05),
#'            caption = "Controlling for weight" ,
#'            describe = list("mean" = function(x) mean(x,na.rm=TRUE)))
#' cor_mat
#' coef(cor_mat)
#' cor_mat$p
#' plot(cor_mat)
#' cor_2 <- corx(iris[,-5], describe = c(median, IQR = iqr, kurt = kurtosis),
#'          note = "Using shortcuts to select describe functions", triangle = "lower")
#' cor_2
#' @return A list of class 'corx' which includes:
#' \itemize{
#'  \item{"call"}{ The call}
#'  \item{"apa"}{ An 'APA' formatted correlation matrix with significance stars}
#'  \item{"r"}{ Raw correlation coefficients}
#'  \item{"p"}{ Raw p-values}
#'  \item{"n"}{ Pairwise observations}
#'  \item{"caption"}{ Object caption}
#'  \item{"note"}{ Object note}
#' }
#' @export

corx_old <-
  function(data,
           x = NULL,
           y = NULL,
           z = NULL,
           method = c("pearson", "spearman", "kendall"),
           stars = c(0.05),
           round = 2,
           remove_lead = TRUE,
           triangle = NULL,
           caption = NULL,
           note = NULL,
           describe = FALSE,
           grey_nonsig = TRUE,
           call_only = FALSE) {


    call = match.call()
    env = environment()
    parent_env = sys.frame(sys.parent())
    if(call_only) return(list(call = call, env = env, parent_env = parent_env))

    if(nrow(data) < 3){
      stop("Can't calculate p-values with fewer than four rows of data.")
    }

    if(is(data, "matrix")) data <- data.frame(data, check.names = FALSE)

    # select vars and check names ----------------------

    x = tidyselect::vars_select(colnames(data), {{x}}, .strict = F)
    y = tidyselect::vars_select(colnames(data), {{y}}, .strict = F)
    z = tidyselect::vars_select(colnames(data), {{z}}, .strict = F)

    # allow rename within select
    rename_if_needed = function(data, x) {
      rename_vars = x[names(x) != x]
      for (i in seq_along(rename_vars)) {
        if (names(x)[i] != x[i]) {
          colnames(data)[colnames(data) == x[i]] = names(rename_vars[rename_vars == x[i]])
        }
      }

      data
    }

    data = rename_if_needed(data, x)
    data = rename_if_needed(data, y)
    data = rename_if_needed(data, z)

    if(length(x) > 0) x <- names(x)
    if(length(y) > 0) y <- names(y)
    if(length(z) > 0) z <- names(z)
    # --


    check_for_vec = function(names, sym, env){

      if(length(names) == 0 & !is.null(sym)){

        if(as.character(sym) %in% ls(envir = env)){
          #message("getting vec")
          names = get(as.character(sym))
        }

      } else{
        #message("names not length 0 or sym was null")
      }

      return(names)
    }

    x = check_for_vec(x, call$x, parent_env)
    y = check_for_vec(y, call$y, parent_env)
    z = check_for_vec(z, call$z, parent_env)

    # message(length(x))

    get_input = function(x){ # grab plain text input
      x = as.character(x)
      if(length(x)>1) x <- x[-1]
      return(x)
    }
    x_orig = get_input(call$x)
    y_orig = get_input(call$y)
    z_orig = get_input(call$z)



    to_check = c()

    if(length(x) == 0 & length(x_orig) > 0){ # did the user try to get a var and failed
      to_check = c(to_check, x_orig) # check what the deal is
    }
    if(length(y) == 0 & length(y_orig) > 0){
      to_check = c(to_check, y_orig)
    }
    if(length(z) == 0 & length(z_orig) > 0){
      to_check = c(to_check, z_orig)
    }

    check_names(data, unique(to_check))

    #check_names(data, c(x, y, z)) # check all names are present

    if(length(x) == 0){
      x = names(data)
    }

    if(length(y) == 0){
      y = x
    }

    if(length(z) == 0){
      z = NULL
    }

    if(length(z) > 0){ #remove partialled out variable from x and y
      x = x[!x %in% z]
      y = y[!y %in% z]
    }



    if(length(x) == 0 | length(y) == 0) stop("Can't partial out the entirety of x or y")

    # check classes are appropriate
    check_classes(data[,unique(c(x,y,z))], c("numeric","integer"), "All classes must be numeric.")


    method = method[1] # take the first method in case more than one supplied


    if (length(z) == 0) { # if no partial set
      cors = psych::corr.test(data[, x], data[, y], method = method, adjust = "none") # standard cors
      cors$n = psych::pairwiseCount(data[,x], data[,y])

      r_matrix = as.matrix(cors$r)
      p_matrix = as.matrix(cors$p)
      n_matrix = as.matrix(cors$n)

      colnames(r_matrix) = y ;colnames(n_matrix) = y ;colnames(p_matrix) = y # sometimes col/row names get stripped
      rownames(r_matrix) = x ;rownames(n_matrix) = x ;rownames(p_matrix) = x # so I force them back on

    } else{

      cors = partial_matrix(data, x = x, y = y, method = method, partial = z) # if partial not null use different method

      r_matrix = cors$r
      p_matrix = cors$p
      n_matrix = cors$n

    }

    pres_matrix = apa_matrix(r_matrix, #get apa matrix
                                      p_matrix,
                                      stars,
                                      round,
                                      remove_lead,
                                      triangle)

    # describe function ----------------------------------------------------

    # allow shortcuts

    all_desc = list(mean = function(x) mean(x, na.rm=T),
                    sd = function(x) stats::sd(x, na.rm=T),
                    var = function(x) stats::var(x, na.rm = T),
                    median = function(x) stats::median(x, na.rm = T),
                    iqr = function(x) stats::IQR(x, na.rm = T),
                    skewness = function(x) moments::skewness(x, na.rm = T),
                    kurtosis = function(x) moments::kurtosis(x, na.rm =T)
                    )

    tryCatch({ # allow lists to be sent to tidyselect
    describe_name = tidyselect::vars_select(names(all_desc), {{describe}}, .strict = F)
    }, error = function(e) assign("describe_name", c(), envir = env)) # assign empty vec if error

    if(length(describe_name) > 0){ # if vars were found

      if(length(describe_name) != (length(call$describe) -1)){ # check if all vars were found
      describe_name = tidyselect::vars_select(names(all_desc), {{describe}}, .strict = T)
      }

      describe = all_desc[describe_name] # set describe to all_desc
      names(describe) = names(describe_name) # rename as needed
    }

    if (!identical(describe, F)) { # if describe is selected
      if (identical(describe, T)) { # if it is equal to true
        describe = list( # define default describe functions
          "M" = function(x)
            mean(x, na.rm = TRUE),
          "SD" = function(x)
            stats::sd(x, na.rm = TRUE)
        )
      }

      data = data.frame(data)
      x = make.names(x)

      orig_names = colnames(pres_matrix)
      pres_matrix = data.frame(pres_matrix)

      for (i in seq_along(describe)) { # then apply describe function to data
        pres_matrix[[names(describe)[i]]] =
          unlist(lapply(seq_along(x), function(var) {
            val = describe[[i]](data[, x[[var]]])
            digits(val, round)
          }))
      }
      pres_matrix = as.matrix(pres_matrix)
      colnames(pres_matrix)[seq_along(orig_names)] = orig_names
    }

    if(!is.null(triangle)){ # if triangle change names -------

      nums = seq_along(rownames(pres_matrix))
      rownames(pres_matrix) = paste0(nums,". ", rownames(pres_matrix))
      colnames(pres_matrix)[1:length(nums)] = nums
      pres_matrix = pres_matrix[,-length(nums)]
    }

    # add in note --------------------------------------------

    if(is.null(note)){

    note = lapply(seq_along(stars), function(s){

      temp_stars = paste(rep("*",s), collapse = "")
      paste0(temp_stars, " p < ", stars[s])
    })

    note = paste(note, collapse = "; ")
    }

    c_matrix = list(
      call = call,
      apa = pres_matrix,
      r = r_matrix,
      p = p_matrix,
      n = n_matrix,
      caption = caption,
      note = note
    )
    class(c_matrix) = "corx"
    attr(c_matrix, "grey_nonsig") = grey_nonsig
    attr(c_matrix, "stars") = stars
    attr(c_matrix, "round") = round
    attr(c_matrix, "describe") = describe

    return(c_matrix)
  }







